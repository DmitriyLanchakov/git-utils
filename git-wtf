#!/usr/bin/env ruby

require 'pp'
$debug = false

require 'yaml'
CONFIG_FILENAME = ".git-wtf"

class Numeric; def pluralize s; "#{to_s} #{s}" + (self != 1 ? "s" : "") end end

def die s
  $stderr.puts "Error: #{s}"
  exit(-1)
end

def run_command(command)
  output = IO.popen(command, 'r').read

  if $debug
    puts "-- begin run_command --"
    puts "executing: #{command}"
    puts "output:"
    puts output
    puts "-- end run_command --"
  end

  output
end

def commits_between from, to
  run_command(%{ git log --pretty=format:"- [%h] %s" #{from}..#{to} }).split(/[\r\n]+/).map { |s| s.gsub(/- /, '') }
end

begin
  $config = YAML::load_file(CONFIG_FILENAME)
  raise 'invalid configuration format' unless $config["version_branches"].length > 0
rescue
  puts <<-CONFIG.gsub(/^  /, '')
  Create a .git-wtf in your git repository directory that looks like:
  --
  version_branches:
    - stable-2.0
  CONFIG
  exit 1
end

current_branch = File.read(File.join('.git', 'HEAD')).chomp.split('/').last

branches = Dir[File.join('.git', 'refs', 'heads', '*')].inject({}) do |hash, ref|
  name    = File.basename(ref)
  rev     = File.read(ref).chomp
  current = (name == current_branch)
  version = $config["version_branches"].include?(name)
  remote  = run_command("git config --get branch.#{name}.remote").chomp
  merge   = run_command("git config --get branch.#{name}.merge").chomp.split('/').last

  hash.update({ name => {
    :name    => name,
    :rev     => rev,
    :current => current,
    :version => version,
    :parent  => {
      :remote => remote,
      :branch => merge
    }
  }})
end

remotes = Dir[File.join('.git', 'refs', 'remotes', '*', '*')].inject({}) do |hash, ref|
  ref_parts = ref.split('/')
  name   = ref_parts.pop
  remote = ref_parts.pop
  rev    = File.read(ref).chomp
  hash[remote] ||= {}
  hash[remote][name] = { :name => name, :remote => remote, :rev => rev }
  hash
end

branches.each do |name, branch|
  branches[name][:remote] = begin
    parent = branch[:parent]
    remote = parent[:remote] == '.' ? branches : remotes[parent[:remote]]
    remote[parent[:branch]]
  end
end

repo = {
  :master   => branches.values.detect { |b| b[:name] == 'master' },
  :current  => branches.values.detect { |b| b[:current] },
  :versions => branches.values.select { |b| b[:version] },
  :features => branches.values.select { |b| !(b[:version] || b[:name] == 'master') },
  :remotes  => remotes
}

def branch_sync_status(local, remote, show_outgoing=true, show_incoming=true, good="in sync", bad="out of sync")
  outgoing = show_outgoing ? commits_between(remote[:rev], local[:rev])  : []
  incoming = show_incoming ? commits_between(local[:rev],  remote[:rev]) : []

  sync = (incoming.length == 0 && outgoing.length == 0)

  verb = case
    when incoming.length > 0 &&
         outgoing.length > 0 then 'merge'
    when incoming.length > 0 then 'pull'
    when outgoing.length > 0 then 'push'
    else nil
  end

  puts sync ? "[x] #{good}" : "[ ] #{bad}"
  incoming.each { |c| puts "    < #{c}" }
  outgoing.each { |c| puts "    > #{c}" }

  puts
end


puts "Local Branch: #{repo[:current][:name]}"
branch_sync_status(repo[:current], repo[:current][:remote], true, true, "in sync with remote", "out of sync with remote (#{repo[:current][:parent][:remote]}/#{repo[:current][:parent][:branch]})")

if repo[:current] == repo[:master]
  puts "Version Branches:"
  repo[:versions].each do |branch|
    branch_sync_status(repo[:current], branch, false, true, "#{branch[:name]} is merged in", "#{branch[:name]} needs to be merged in")
  end
elsif repo[:versions].include?(repo[:current])
  master = repo[:master]
  puts "Master Branch: #{master[:name]}"
  branch_sync_status(repo[:current], master, true, false, "in sync", "#{repo[:current][:name]} needs to be merged into master")
end

if repo[:features].length > 0
  puts "Feature Branches:"
  repo[:features].each do |branch|
    branch_sync_status(repo[:current], branch, false, true, "#{branch[:name]} is merged in", "#{branch[:name]} needs to be merged in")
  end
end